const axios = require('axios');
const R = require('ramda');
const moment = require('moment');

const makePlaylistBuilder = require('./builder.js');
const { getOAuthHeader } = require('../oauth2Service');

const SPOTIFY_PLAYLIST_PUT_LIMIT = 100;

/**
 * Creates an empty playlist for a user
 * @param {userId, accessToken} userOpts
 * @param {name, description} playlistOpts
 * @returns {err, result}
 */
async function createEmptyPlaylist(userId, accessToken, playlistOpts) {
  const { name, description } = playlistOpts;
  if (![name, description].every(e => !!e)) {
    console.warn('Missing playlist metadata to create playlist!');
    return { err: 'Playlist metadata required!' };
  }

  const opts = {
    headers: getOAuthHeader(accessToken),
  };
  try {
    const res = await axios.post(
      `https://api.spotify.com/v1/users/${userId}/playlists`,
      playlistOpts,
      opts
    );
    const { id } = res.data;
    return { result: id };
  } catch (err) {
    console.error('Error while creating playlist for user: ');
    console.error(err.config);
    console.error(err.response.status);
    console.error(err.response.data);
    throw err;
  }
  return {};
}

// Replace with PUT limit = 100 tracks / actually calculate diff (get all IDs, remove diff(left), add diff(right))
async function putPlaylistSongs(
  userId,
  accessToken,
  playlistId,
  tracks,
  limit = SPOTIFY_PLAYLIST_PUT_LIMIT
) {
  const opts = {
    headers: getOAuthHeader(accessToken),
  };
  const getTrackUri = R.pipe(R.prop('uri'));
  const getTrackUris = R.pipe(
    R.take(limit),
    R.map(getTrackUri)
  );
  const requestBody = {
    uris: getTrackUris(tracks),
  };
  if (!requestBody.uris.every(e => !!e)) {
    console.error('Bad track uris: ', requestBody.uris);
    return { err: 'Bad track uris: ' + requestBody.uris };
  }
  const res = await axios.put(
    `https://api.spotify.com/v1/users/${userId}/playlists/${playlistId}/tracks`,
    requestBody,
    opts
  );
  return {};
}

// https://developer.spotify.com/documentation/web-api/reference/playlists/change-playlist-details/
async function putPlaylistDetails(
  userId,
  accessToken,
  playlistId,
  playlistDetails
) {
  const opts = {
    headers: getOAuthHeader(accessToken),
  };
  const res = await axios.put(
    `https://api.spotify.com/v1/users/${userId}/playlists/${playlistId}`,
    playlistDetails,
    opts
  );
}

async function updatePlaylistLastSynced(userId, accessToken, playlistId) {
  const playlistDetails = {
    description: `Generated by Songbird | Last synced: ${moment().format(
      'LL'
    )}`,
  };
  await putPlaylistDetails(userId, accessToken, playlistId, playlistDetails);
}

// Retrieves playlist with given spotify playlist ID. Not really used
async function getPlaylist(userId, accessToken, playlistId) {
  const opts = {
    headers: getOAuthHeader(accessToken),
  };
  const res = await axios.get(
    `https://api.spotify.com/v1/users/${userId}/playlists/${playlistId}`,
    opts
  );
  return res.data;
}

// Retrieves a list of user's playlists. Gets a paged object
// Currently uses the current user method, instead of calling with server's accessToken
async function _getUserPlaylists(accessToken, { offset = 0, limit = 50 }) {
  const opts = {
    headers: getOAuthHeader(accessToken),
  };
  const res = await axios.get('https://api.spotify.com/v1/me/playlists', opts);
  const { next, items: playlists, total } = res.data;
  return { result: { next, playlists, total } };
}

async function getAllUserPlaylists(accessToken, maxLimit = 1000) {
  const limit = 50;
  const allPlaylists = [];

  // Default maxLimit limits per user to request up to 5 times
  for (let i = 0; i < maxLimit; i += limit) {
    const { result } = await _getUserPlaylists(accessToken, {
      offset: i,
      limit,
    });
    const { next, playlists, total } = result;
    allPlaylists.push(...playlists);
    // Spotify uses a circular array for this, so it wont end unless we stop when we exceed the total
    if (!next || i + limit > total) {
      break;
    }
  }
  return { result: allPlaylists };
}

function leftDifference(setA, setB) {
  var _difference = new Set(setA);
  for (let elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}

function intersection(setA, setB) {
  var _intersection = new Set();
  for (let elem of setB) {
    if (setA.has(elem)) {
      _intersection.add(elem);
    }
  }
  return _intersection;
}

// Checks if any of the playlists are no longer there (stale subscription)
// Also useful to check how many playlists user has
// TODO can make this and userHasPlaylist to return early instead of getting all playlists
async function getStalePlaylists(accessToken, subscriptions) {
  const { result: playlists } = await getAllUserPlaylists(accessToken);
  const libraryPlaylistIds = playlists.map(e => e.id);
  const subscriptionIds = subscriptions.map(e => e.spotify_playlist_id);
  const libSet = new Set(libraryPlaylistIds);
  const subSet = new Set(subscriptionIds);
  const staleSet = leftDifference(subSet, libSet);
  const active = [];
  const stale = [];
  for (let subscription of subscriptions) {
    if (staleSet.has(subscription.spotify_playlist_id)) {
      stale.push(subscription);
    } else {
      active.push(subscription);
    }
  }

  return {
    result: {
      active,
      stale,
    },
  };
}

async function userHasPlaylist(accessToken, playlistId) {
  const { result: playlists } = await getAllUserPlaylists(accessToken);
  const playlistIds = playlists.map(e => e.id);
  return { result: playlistIds && playlistIds.includes(playlistId) };
}

// TODO something will go wrong with create react app?
module.exports = {
  // Functions
  createEmptyPlaylist,
  putPlaylistSongs,
  getPlaylist,
  getAllUserPlaylists,
  userHasPlaylist,
  updatePlaylistLastSynced,
  makePlaylistBuilder,
  getStalePlaylists,
};
